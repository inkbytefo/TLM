"""
Autonomous Agent Loop for Spectral-JAX.
Implements a Real-Time / Full-Duplex architecture where the model runs in a continuous loop,
handling silence, internal monologue, and proactive speech.
"""

import time
import sys
import jax
import jax.numpy as jnp
import numpy as np
from typing import List, Optional, Tuple

from config import Config, AgentLoopConfig
from src.models.gpt import SpectralGPT
from src.utils.common import setup_logger, set_seed

# Special Tokens from Config
SILENCE_TOKEN = AgentLoopConfig.SILENCE_TOKEN
WAIT_TOKEN = AgentLoopConfig.WAIT_TOKEN
THINK_TOKEN = AgentLoopConfig.THINK_TOKEN
SPEAK_TOKEN = AgentLoopConfig.SPEAK_TOKEN

class AgentLoop:
    def __init__(self):
        self.config = Config()
        self.logger = setup_logger()
        self.logger.info("Initializing Autonomous Agent Loop...")
        
        # Initialize Model
        self.model = SpectralGPT(
            vocab_size=self.config.model.vocab_size,
            hidden_dim=self.config.model.hidden_dim,
            num_layers=self.config.model.num_layers,
            dropout_rate=0.0, # No dropout during inference
            use_memory=self.config.model.use_memory,
            memory_dim=self.config.model.memory_dim,
            memory_interval=self.config.model.memory_interval
        )
        
        # Initialize Parameters
        self.rng = jax.random.PRNGKey(42)
        self.rng, init_rng = jax.random.split(self.rng)
        
        dummy_input = jnp.zeros((1, 1), dtype=jnp.int32)
        self.variables = self.model.init(init_rng, dummy_input, train=False)
        self.params = self.variables['params']
        
        # Initialize State
        self.memory_state = None # Will be initialized by model on first pass if None
        self.history = [] # Keep track of conversation for context (optional, model has memory)
        self.silence_counter = 0
        
        self.logger.info("Agent initialized and ready.")

    def step(self, input_token: int) -> int:
        """
        Run one step of the agent loop.
        
        Args:
            input_token: The token to feed into the model.
            
        Returns:
            output_token: The token generated by the model.
        """
        # Prepare input
        input_seq = jnp.array([[input_token]], dtype=jnp.int32) # (1, 1)
        
        # Forward pass with current memory state
        logits, new_memory_state = self.model.apply(
            {'params': self.params},
            input_seq,
            init_memory_state=self.memory_state,
            train=False
        )
        
        # Update memory state
        self.memory_state = new_memory_state
        
        # Greedy decoding for now
        next_token_logits = logits[0, -1, :]
        next_token = int(jnp.argmax(next_token_logits))
        
        return next_token

    def run(self):
        """
        Main execution loop.
        """
        print("\n=== Autonomous Agent Loop Started ===")
        print("Type something and press Enter. The agent is listening...")
        print("(Press Ctrl+C to exit)\n")
        
        try:
            while True:
                # 1. Check for User Input (Non-blocking check would be ideal, but for now we simulate)
                # For this prototype, we'll use a simple input() but in a real real-time system
                # this would be a non-blocking read from a buffer.
                
                # To simulate "Silence", we can check if input is available.
                # Since standard input() is blocking, we will simulate the loop structure:
                # We will assume the user inputs something, process it, and then
                # the agent can "think" or "wait" in a loop until it decides to speak or user interrupts.
                
                # Ideally:
                # if input_available():
                #    token = read_input()
                # else:
                #    token = SILENCE_TOKEN
                
                # For this CLI demo, we'll implement a simplified version:
                # The agent waits for input. If input is empty (just Enter), it counts as Silence.
                
                try:
                    user_text = input("USER (or Enter for Silence): ")
                except EOFError:
                    print("\n[System] Input stream closed. Exiting.")
                    break
                
                if user_text:
                    # Process User Input
                    # Convert text to bytes/tokens
                    input_tokens = list(user_text.encode('utf-8'))
                    
                    # Feed tokens one by one
                    for token in input_tokens:
                        output = self.step(token)
                        # We ignore output while processing user input, 
                        # unless we want the agent to interrupt (advanced).
                        
                    # After user input, feed a special delimiter or just let it run?
                    # Let's feed a newline to mark end of input
                    last_output = self.step(ord('\n'))
                    
                else:
                    # Silence
                    last_output = self.step(SILENCE_TOKEN)
                    self.silence_counter += 1
                
                # Debug: Check if memory state exists
                if self.memory_state is not None:
                     # Just print the norm of the first memory state to show it's changing/persisting
                     # self.memory_state is a list of arrays (one per layer)
                     # Wait, in gpt.py we appended to new_memory_states list
                     # So self.memory_state is a list of arrays.
                     # Let's print the norm of the first one.
                     try:
                         state_norm = jnp.linalg.norm(self.memory_state[0])
                         # print(f"[DEBUG] Memory State Norm: {state_norm:.4f}")
                     except:
                         pass

                # 2. Agent Reaction Loop
                # The agent now has the "turn". It can produce tokens until it yields.
                # In a full-duplex system, this would happen in parallel.
                
                current_token = last_output
                response_tokens = []
                
                # Allow agent to generate up to N tokens or until it waits
                for _ in range(100): 
                    # Decide action based on token
                    if current_token == WAIT_TOKEN:
                        print(f"[AGENT]: <WAIT> (Silence count: {self.silence_counter})")
                        break # Agent yields turn
                        
                    elif current_token == THINK_TOKEN:
                        print(f"[AGENT]: <THINK> ...")
                        # Internal thought, continue loop but don't show output
                        # In reality, we might want to log this to a private channel
                        pass
                        
                    elif current_token == SILENCE_TOKEN:
                         # Model decided to be silent
                         print(f"[AGENT]: <SILENCE>")
                         break
                         
                    elif current_token == SPEAK_TOKEN:
                        print(f"[AGENT]: <SPEAK>")
                        # Start speaking mode
                        pass
                        
                    else:
                        # Normal token, print it
                        # If it's a byte, decode it
                        try:
                            char = bytes([current_token]).decode('utf-8')
                            print(char, end='', flush=True)
                            response_tokens.append(current_token)
                        except:
                            pass # Partial byte or non-printable
                            
                    # Generate next token (Auto-regressive)
                    # Feed its own output back as input
                    current_token = self.step(current_token)
                    
                print() # Newline after response

        except KeyboardInterrupt:
            print("\n[System] Agent Loop Terminated.")

if __name__ == "__main__":
    agent = AgentLoop()
    agent.run()
